from __future__ import annotations

from typing import List

import torch

from app.models.ddi_graph import DDIGraph
from app.models.simple_pmrs import SimplePMRSModel
from app.schemas.medication import (
    MedicationSuggestion,
    RecommendationRequest,
    RecommendationResponse,
)

# Build demo model + resources once, at import time.
_model, _vocab, _meds = SimplePMRSModel.build_demo()
_ddi_graph = DDIGraph.demo()

# Put model in eval mode and choose a deterministic seed for reproducibility.
torch.manual_seed(42)
_model.eval()


def _encode_request_to_tokens(req: RecommendationRequest) -> torch.Tensor:
    """Very simple encoding: map known tokens, ignore unknown.

    In your full thesis implementation you would:
    - map ICD, procedure and drug codes to IDs,
    - tokenize clinical notes,
    - handle longitudinal visits, etc.
    """
    tokens: List[int] = []

    def add_token_if_known(name: str):
        key = name.strip().upper()
        for vocab_token, idx in _vocab.items():
            if vocab_token.upper() in key:
                tokens.append(idx)

    for dx in req.diagnoses:
        add_token_if_known(f"DX_{dx}")
    for proc in req.procedures:
        add_token_if_known(f"PROC_{proc}")
    for med in req.current_medications:
        add_token_if_known(f"MED_{med}")
    if not tokens:
        tokens.append(0)  # PAD

    token_tensor = torch.tensor(tokens, dtype=torch.long).unsqueeze(0)
    return token_tensor


def recommend_medications(req: RecommendationRequest, top_k: int = 3) -> RecommendationResponse:
    x = _encode_request_to_tokens(req)
    with torch.no_grad():
        probs = _model(x)[0].tolist()

    # Sort meds by score
    scored = list(zip(_meds, probs))
    scored.sort(key=lambda p: p[1], reverse=True)
    top = scored[:top_k]

    # Apply a simple DDI filter: if any pair among the top-k is risky,
    # we keep the highest ranked medication and drop the lower one.
    safe_meds: List[str] = []
    suggestions: List[MedicationSuggestion] = []

    for drug, score in top:
        # Check against already accepted meds for DDI.
        has_conflict = any(_ddi_graph.has_ddi(drug, other) for other in safe_meds)
        warnings: List[str] = []
        if has_conflict:
            warnings.append(
                "Omitted from final set due to toy DDI conflict with another suggested drug. "
                "In a real system this would refer to a clinically validated DDI knowledge base."
            )
            # We still show it in the suggestions list, but you might also choose to hide it in the UI.
        else:
            safe_meds.append(drug)

        suggestions.append(
            MedicationSuggestion(
                drug_code=drug,
                name=f"Demo medication {drug}",
                score=float(score),
                warnings=warnings,
            )
        )

    ddi_warnings = _ddi_graph.check_combination(safe_meds)

    disclaimer = (
        "This PMRS demo output is generated by an unvalidated research model and a toy DDI graph. "
        "It is strictly for academic demonstration and must NOT be used for any real-world medical "
        "decision-making, diagnosis, or treatment."
    )

    return RecommendationResponse(
        suggestions=suggestions,
        ddi_warnings=ddi_warnings,
        disclaimer=disclaimer,
    )
